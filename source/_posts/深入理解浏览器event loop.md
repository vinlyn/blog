---
title: 深入理解浏览器event loop
date: 2018-01-06 13:30:36
categories: [JavaScript]
tags: [JavaScript, event loop]
---
### 写在前面
上一篇的[《关于eventloop的理解》](http://vinlynweb.com/2018/01/03/%E5%85%B3%E4%BA%8Eeventloop%E7%9A%84%E7%90%86%E8%A7%A3/)只是通过setTimeout大概讲了一下eventloop的概念，没有讲详细的例子，或许还处于懵懵的状态。下面将通过setTimeout、Promise，Dom Event在浏览器是怎么运行的来更加清晰的了解event loop。
### 先来几个简单
```js
console.log('A');
setTimeout(() => {
  console.log('C');
}, 100)
console.log('B');
// 输出结果 A B C，上篇文章有解释

for (var i = 0; i < 5; i++) {
 setTimeout(() => {
 console.log(i);
 }, 1000 * i);
}
// 立即输出5，每隔1s输出一个5，因为setTimeout的callback后面才进入的执行栈，这时候i
// 已经是5了，恩~ 这个看起来也简单。（题目有点老，这个地方用let的话，不会产生坑了）

console.log('A')
Promise.resolve().then(() => {
  console.log('C')
}).then(() => {
  console.log('D')
})
console.log('E')
// 结果 A E C D，这个结果也很容易解释。

console.log(A)
document.querySelector('.inner').addEventListener('click', () => {
  console.log(C)
})
console.log(B)
// 运行完，输出A B，单击inner，输出C。
// 以上，都很简单，就是浏览器模块处理对应异步事件，然后达到对应触发条件，事件进入任务队列，执行栈执行。
```

### 再来几个复杂
#### 例子1：setTimeout与Dom Event
```js
setTimeout(() => {
  console.log(1);
}, 0);
document.getElementById('btn').addEventListener('click', () => {
  console.log('click')
});
let now = new Date().getTime();
while((new Date()).getTime() - now < 3000) {
}
console.log(22);
```
主线程卡3s，在3s内点击按钮，然后3s后，查看输出。先来看看输出结果：
<img src="/images/eventloop/eventloop18.gif" style="width: 500px;">
那么问题来了，按照之前的逻辑，setTimeout因为延迟为0，按照常理1的输出应该是在click之前的，那么为什么1会在click之后输出呢，奇不奇怪。透过实验还能看得出主线程卡住的时候，UI的渲染也是无法执行的，在3s内点击按钮无点击效果，3s后就有效果。
#### 例子2：setTimeout与Promise
```js
setTimeout(function() {console.log(1)}, 0);
new Promise((resolve) => {
    console.log(2);
    let now = new Date().getTime();
    while((new Date()).getTime() - now < 1000) {
    }
    resolve();
    console.log(3);
}).then(function() {
    console.log(4);
});
console.log(5);
```
输出结果：输出2，卡1s，然后依次输出3，5，4，1；
那么问题又来了，1 后面输出可以理解，为什么4要在1前面，而且为什么2，3要在5前面，恩~ 感觉有点乱。
#### 例子3：setTimeout与Promise与Dom Event
```js
setTimeout(() => {
  console.log(1);
}, 0);
document.getElementById('btn').addEventListener('click', () => {
  console.log('click')
});
new Promise((resolve) => {
    console.log(2);
    resolve();
    console.log(3);
}).then(function() {
    console.log(4);
});
let now = new Date().getTime();
while((new Date()).getTime() - now < 3000) {
}
console.log(5);
```
<img src="/images/eventloop/eventloop20.gif" style="width: 500px;"> 
以上输出结果，那么可以看得出来，4在click之前，而1在click之后。那又是为什么呢？

### 通过标准再说说event loop是怎么处理的
那么下来看看w3c的标准定义[event loop](https://www.w3.org/TR/html5/webappapis.html#event-loops)：
>An event loop has one or more task queues. A task queue is an ordered list of tasks。
When a user agent is to queue a task, it must add the given task to one of the task queues of the relevant event loop.
Each task is defined as coming from a specific task source. All the tasks from one particular task source and destined to a particular event loop 
(e.g., the callbacks generated by timers of a Document, the events fired for mouse movements over that Document, the tasks queued for the parser of that Document) must always be added to the same task queue, but tasks from different task sources may be placed in different task queues.
For example, a user agent could have one task queue for mouse and key events (the user interaction task source), and another for everything else. The user agent could then give keyboard and mouse events preference over other tasks three quarters of the time, keeping the interface responsive but not starving other task queues, and never processing events from any one task source out of order.

对上述语句的理解：事件循环有一个或者多个任务队列。且事件循环读取这些任务队列的是有顺序的。当一个任务需要排队的时，会根据该任务的来源，把它添加到特定的任务队列中，比如计时器的回调，鼠标操作触发的时间等。相同的的任务源添加的任务队列是一致的。不同的任务源可能添加到同一个任务队列中。
然后为了界面的及时响应和用户体验，鼠标操作和一些关键的事件的队列，可能是会比其他的任务队列来得优先。那么例子1大概也就有了答案。

>An event loop must continually run through the following steps for as long as it exists:
1.Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the Microtasks step below.
2.Set the event loop’s currently running task to the task selected in the previous step.
3.Run: Run the selected task.
4.Set the event loop’s currently running task back to null.
5.Remove the task that was run in the Run step above from its task queue.
6.Microtasks: Perform a microtask checkpoint.
7.Update the rendering: If this event loop is a browsing context event loop (as opposed to a Worker event loop), then run the following substeps.
  7.1 Let now be the value that would be returned by the Performance object's now() method. [HRT]
  7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:
  7.3 If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context's top-level browsing context is in B.
  7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.
  7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
  7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
  7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]
  7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]
  7.9 For each fully active Document in docs, run the fullscreen steps for that Document, passing in now as the timestamp. [FULLSCREEN]
  7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.
  7.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]
  7.12 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.
8.If this is a Worker event loop (i.e., one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps.
9.Return to the first step of the event loop.

上述是event loop的每轮的执行。
1~5，从任务队列中选出一个最老的，有就执行它，然后删除它，没有就跳到第六步。
6，执行microtask检查点，就是执行microtask队列中的所有任务，直到队列为空。如果microtask中又添加了新的任务，直接放进本队列末尾。
7，浏览器执行UI render，
  7.1-7.4. 判断这个时间点渲染界面是否能从中受益，浏览器是保证60HZ的刷新就可以了，有时会更低，event loop如果每轮的的速度很快，那么即使UI已经render了，浏览器没有及时显示，那就浪费资源了，所以并不是每轮event loop之后都会进行UI render的。
  7.5-7.9. 执行各种渲染所需工作，如触发 resize、scroll 事件、建立媒体查询、运行 CSS 动画等等
  7.10. 执行requestAnimationFrame callback
  7.11. 执行 IntersectionObserver callback
  7.12. 渲染 UI
9，运行完之后回到第一步。

那么上述的一个流程就是这样子的，事件循环选择任务队列中，最老的一个任务队列来执行，执行完后去执行Microtask，执行完后再去执行UI render（这里不一定执行），然后继续第一步。

那么从上述的步骤还可以知道两个点：
1. Microtask是尽可能早的执行，只要有一个任务队列执行完，事件循环就去查看Microtask是否有新的任务，有就执行。
2. UI Render是在每轮的event loop队列执行完后，来决定到底到底触不触发的。

### Microtask和Macrotask(其他task)
#### [Microtask](https://www.w3.org/TR/html5/webappapis.html#microtask-queue)
>Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue.

每一个事件循环都有一个microtask队列，microtask是在microtask队列上的任务而不是任务队列上排队的任务。（后面这句话可以理解为在microtask队列上的任务就是microtask，而不再就不是？）

microtask包括以下几种： Promises, Object.observe, MutationObserver

#### [Macrotask(其他task)](https://www.w3.org/TR/html5/webappapis.html#microtask-queue)
>Generic task sources
The DOM manipulation task source
The user interaction task source
The networking task source
The history traversal task source

Macrotask的主要来源有上面几种：
1. DOM 操作任务源：如元素以非阻塞方式插入文档
2. 用户交互任务源：如鼠标键盘事件。用户输入事件（如键盘或鼠标输入）
3. 网络任务源：如XHR回调
4. history回溯任务源：使用history.back()或者类似API
5. setTimeout/setInterval
6. 对于数据库操作等I/O操作

### 解题
#### 例子1
```js
// 开始执行首个task
// 立刻把callback加入相应的任务队列
setTimeout(() => {
  console.log(1);
}, 0);
// 点击的时候，把callback加入响应的任务队列
document.getElementById('btn').addEventListener('click', () => {
  console.log('click');
});
// 卡3s
let now = new Date().getTime();
while((new Date()).getTime() - now < 3000) {   
}
// 输出22
console.log(22);
// 因为while卡三秒，3秒后输出22，第一轮event loop执行完毕。
// 第二轮执行开始，选择任务队列，Dom Event优先级比setTimeout高，输出click，第二次event loop完毕。
// 第三轮执行开始，继续选择任务队列，只剩下setTimeout的callback，输出1。
```
#### 例子2
```js
// 开始执行首个task
// 立刻把callback加入相应的任务队列
setTimeout(function() {console.log(1)}, 0);  
new Promise((resolve) => {
    // 输出2
    console.log(2);
    //卡1s
    let now = new Date().getTime();
    while((new Date()).getTime() - now < 1000) {  
    }
    // 把callback加入microtask队列中
    resolve();  
     // 输出3
    console.log(3); 
}).then(function() {
    console.log(4);
});
// 输出5
console.log(5); 
// 首个task执行完之后，event loop发现microtask队列中有任务。
// 拿出任务执行，输出4，第一轮event loop执行完毕。
// 第二轮event loop，输出1。
```
#### 例子3
```js
setTimeout(() => {
  console.log(1);
}, 0);
document.getElementById('btn').addEventListener('click', () => {
  console.log('click')
});
new Promise((resolve) => {
    console.log(2);
    resolve();
    console.log(3);
}).then(function() {
    console.log(4);
});
let now = new Date().getTime();
while((new Date()).getTime() - now < 3000) {
}
console.log(5);
// 第一轮，执行首次task输出 2，3，5，3
// 第二轮，输出两次click（因为点了两次）
// 第三轮，输出1
```
#### 例子4（最后来复杂的总结下）
```js
// 开始执行首个task
// 输出start
console.log('start')
// 交由定时器处理，一直往任务队列里面添加callback
let interval = setInterval(() => {
  console.log('setInterval')
}, 0)
// 交由定时器处理，立即任务队列里面添加callback
setTimeout(() => {  
  console.log('setTimeout 1')
  // 第二轮，event loop执行task阶段。callback('promise 3')，
  // callback('promise 4')，callback('setTimeout')添加到microtask，
  Promise.resolve()
      .then(() => {
        console.log('promise 3')
      })
      .then(() => {
        console.log('promise 4')
      })
      .then(() => {
        // 第三轮，event loop执行task阶段。输出 setTimeout 2，
        // callback('promise 5')，callback('promise 6')添加到microtask，
        setTimeout(() => {
          console.log('setTimeout 2')
          Promise.resolve()
              .then(() => {
                console.log('promise 5')
              })
              .then(() => {
                console.log('promise 6')
              })
              .then(() => {
                clearInterval(interval)
              })
        }, 0)
      })
}, 0)

// 执行往microtask添加callback('promise 1')和callback('promise 2')
Promise.resolve()
.then(() => {  
    console.log('promise 1')
})
.then(() => {
    console.log('promise 2')
})

// 输出结果：
// start  promise 1  promise 2  setInterval  setTimeout 1  promise 3
// promise 4  setInterval  setTimeout 2  promise 5  promise 6

// 第一轮event loop，输出start，执行microtask任务，输出promise 1，promise 2，第一轮结束。
// 第二轮，选择任务队列执行，输出setInterval，setTimeout 1，setTimeout 1添加响应的任务到
// microtask，任务队列执行结束后，执行microtask队列，输出promise 3，promise 4，第二轮结束。
// 第三轮，选择任务队列执行，输出setInterval（这里chrome输出两次，safari输出一次，这个跟浏览
// 器的实现机制应该有关），setTimeout 2，任务队列执行完，执行执行microtask队列，输出promise 5，
// promise 6。

// 题外话：setInterval往任务队列里面添加回调是有限制的，如果添加的第一个还没有执行，setInterval
// 不会再往队列里面添加了。这个应该会再开一篇文章讨论一下。
```

### 最终总结
整个event loop的过程不再重复啰嗦，下面总结几个重点：
1.每个event loop都有一个或者多个任务队列，并且任务队列的读取是有序的。
2.不同类型任务源的任务会被添加到不同的任务队列里。
3.microtask队列总是尽可能早的执行，只要js执行栈为空，就会去查看microtask队列是否有任务。
4.每轮的event loop总是执行完一个任务队列后，会执行microtask队列，然后选择是否进行UI Render。

### 写在最后
以上内容是参考网上各位大佬的文章和查看w3c的标准，然后加上自己的一点理解，以上如有错误遗漏，望更正补充。

### 参考资料
[对event loop事件循环的理解](https://github.com/Jmingzi/blog/issues/2)
[深入理解Event Loop机制](https://github.com/yuyue94/blog/issues/6)
[深入浅出Javascript事件循环机制(上)](https://github.com/LuckyAbby/LuckyAbby.github.io/issues/4)
[深入浅出JavaScript事件循环机制(下)](https://github.com/LuckyAbby/LuckyAbby.github.io/issues/5)
[深入探究 eventloop 与浏览器渲染的时序问题](https://github.com/jin5354/404forest/issues/61)
[从Promise来看JavaScript中的Event Loop、Tasks和Microtasks](https://github.com/creeperyang/blog/issues/21)
[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)
[w3c标准：Event loops](https://www.w3.org/TR/html5/webappapis.html#event-loops)